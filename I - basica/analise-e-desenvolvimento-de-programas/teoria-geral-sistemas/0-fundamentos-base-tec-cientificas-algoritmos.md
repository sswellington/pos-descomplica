# Origem e história do algoritmo

os computadores eram em seu nascimento, nada mais do que sofisticadas máquinas de calcular, perceberá o quanto da sua estruturação se originou da matemática. A matemática e a computação sempre andaram juntas na ciência, e não simplesmente onde podemos ver: no caso dos computadores utilizados em extensos cálculos de fórmulas matemáticas diversas, mas também em sua construção lógica. 

 A computação digital nasceu de uma sequência de eventos históricos de evolução da matemática, mais especificamente dos algoritmos, sendo que hoje, estes algoritmos são considerados muito mais do que sua origem, mas sua base de estruturação lógica. 

Não se tem uma data de origem específica para os algoritmos, mas existem muitas linhas de pesquisa e historiadores que a colocam no período de 830 d.C. com a publicação do livro de álgebra, de autoria do matemático e astrônomo muçulmano Abu Abdullah Muhammad Ibn Musa al-Khwarizmi (780 d.C a 850 d.C.) Cujo nome curto seria al-Khwarizmi. De acordo com Wazlawick (2016, p. 13) 

Esta obra foi responsável pela popularização dos algarismos indianos (hoje conhecidos como arábicos ou indo-arábicos) na Europa e Oriente Médio, os quais eram bem mais fáceis de operar do que os números romanos, até então usados. O título do livro foi traduzido para o latim como “Algoritmi de numero Indorum” e assim a tradução para o latim do nome deste matemático passou a significar genericamente qualquer procedimento mecânico para realização de cálculos.  

 

Como podemos observar na imagem do livro (figura 1), a primeira página da tradução para o Latim do livro temos “Dixit algorizmi...”.  

 

Figura 01: Início do livro de al-Khwarizmi


De certa forma podemos compreender que a computação mecânica de cálculos não foi completamente transformada nos computadores digitais, apenas miniaturizada e aplicada com a ajuda da eletricidade. A base de funcionamento dos computadores modernos ainda respeita as leis matemáticas tais como desenvolvidas por al-Khwarizmi em suas técnicas, como as de adição e divisão em números longos (ensinado nas escolas atualmente). 

Entre outras contribuições, al-Khwarizmi mostrou como realizar adições e divisões com números longos, um procedimento (ou algoritmo) até hoje ensinado nas escolas, e que foi a base para a construção das primeiras calculadoras mecânicas. (WAZLAWICK 2016, p. 13) 

Esta postulação de al-Khwarizmi permitiu a estruturação da aplicação mecânica do processo de calcular, ou seja, deu subsídio a criação das primeiras calculadoras mecânicas, pois apresentou com seus números indo-arábicos uma forma muito mais elegante.  

As vantagens podem ser observadas no processo de soma de velocidade maior quando comparada ao processo quando feito usando algarismos romanos, por exemplo com a somatória de XIX + XXI = XL. As regras de soma para a notação romana são complexas:  

Primeiramente os números devem ser descompactados, trocando-se IV por IIII, IX por VIIII etc.: XVIIII+XXI. 
Depois eles são concatenados, ou seja, juntados: XVIIIIXXI. 
Depois deve-se ordenar as letras da mais significativa para a menos significativa: XXXVIIIII. 
Finalmente o número resultante é recomposto: XXXVIIIII = XXXVV = XXXX = XL. 
Bem, a soma até que não era tão difícil, mas a divisão. (WAZLAWICK 2016, p. 13) 
 

Estamos falando de uma era da humanidade onde até mesmo a matemática estava passando por evolução, e com a notação indo-arábica, que era baseada em posições decimais, o avanço foi permitir somas feitas de forma automática, e assim como fazemos atualmente e ensinamos nas escolas, ou seja, da direita para a esquerda.

Devemos os avanços na computação a grandes estudiosos como al-Khwarizmi, mas que com o passar dos anos passou a ser referenciado de formas diferentes, portanto seu nome passou a ser transcrito e sua pronúncia suavizada, como Al-Karismi, Algarismi, até que chegou a algarismo, ficando conhecido como a nomenclatura que referenciava o sistema numérico que utilizamos até hoje.

O termo algoritmo está ligado a computação e também apresenta diversas publicações que o referenciam e o conectam a temas computacionais, embora apresente diversas descrições: de um conjunto de regras formais ou a solução de problemas, com fórmulas e expressões aritméticas.

 

Algoritmos computacionais

 

Do ponto de vista estrutural, algoritmos podem ser vistos como uma estrutura ideológica da mesma forma que são construídas as linguagens de programação dos computadores: desenham o caminho matemático para a solução de determinado problema. Portanto, podemos determinar que se trata de um conjunto de passos, que podem ser repetidos, encarregados de resolver um problema.

Mas de acordo com Manzano (2016) o termo algoritmo causa certa estranheza em alguns momentos, pois os que estranham costumam questionar se a grafia da palavra está correta. Mas os que estranham sua grafia, ignoram sua origem, no latim, e derivam do termo alegorismo, associado a ideia dos algarismos que por sua vez recebe influência do grego aritmós, que representa números.

De acordo com o dicionário Aurélio, conforme Manzano (2016, p. 25), o termo algoritmo é aplicado a computação e sua esfera matemática se associa a um processo de cálculo e de resolução de problemas diversos semelhantes e sem restrições. Já na ciência da computação, o termo representa um conjunto de regras e operações definidos e ordenados, que são destinados à solução de um problema, com um número de passos pré-determinado e finito.

Para Forbellone e Ebersoacher (2005 apud Morais et al. 2018, p. 10), “[...] algoritmo é um conjunto finito de regras, bem definidas, que nos levam à solução de um problema em um tempo finito.” Portanto, o algoritmo contém a descrição de um conjunto de ações, um grupo finito de passos, para que certo objetivo seja atingido. Para que se tenha um algoritmo, é preciso:

a) que se tenha um número finito de passos;

b) que cada passo esteja precisamente definido, sem possíveis ambiguidades;

c) que existam zero ou mais entradas;

d) que existam uma ou mais saídas;

e) que exista uma condição de fim, sempre atingida em tempo finito, para quaisquer entradas.

 

Com esta completa descrição, podemos compreender que, para a computação, os algoritmos representam a base da lógica de programação, que por sua vez representa tanto a coerência e racionalidade, pois a lógica de programação é fundamentalmente um processo explicitamente racional que conduz a construção de um software, que assim como o algoritmo, é capaz de construir sistemas que possam atingir seus objetivos.

Os algoritmos são criados e reconhecidos por sua lógica de programação. Segundo Forbellone e Eberspacher (2005 Morais et al. 2018, p. 10), a lógica está relacionada à coerência e à racionalidade; lógica de programação é a racionalização dos processos formais da programação de computadores e algoritmo é a sequência de passos que visam atingir um objetivo bem definido.

Em sua descrição os algoritmos podem ser descritos graficamente com o uso de diagramas de blocos, ou ainda em sua forma textual com as linguagens formais de programação de computadores. Neste sentido, temos a clara visão de que os algoritmos representam um processo de sistematização da resolução de problemas de forma sequencial e ordenada e para Berlinski (2002, p. 21 apud Manzano 2016, p. 25),

algoritmo é um método finito, escrito em um vocabulário simbólico fixo regido por instruções precisas, que se movem em passos discretos (1, 2, 3...), cuja execução não requer insight, esperteza, intuição, inteligência ou clareza e lucidez, e que mais cedo ou mais tarde chega a um fim. Um algoritmo é qualquer procedimento computacional bem definido que toma algum valor ou conjunto de valores como entradas e produz algum valor ou conjunto de valores como saída.

Para o mundo da computação, um algoritmo vai representar um conjunto formal de regras sequenciais e precisamente definidas, derivadas de uma compreensão lógica de um problema que precisa ser resolvido pelo programador que está a construir determinado software.

Para quem cruza com as definições de algoritmo e de lógica de programação pode ser um desafio compreender e dar sentido a tudo, principalmente aos que não são do meio informático, mas vale ressaltar que as vezes a dificuldade reside em um conceito muito mais simples e facilmente incompreendido: o conceito de problema.

De forma puramente conceitual, um problema é uma proposta duvidosa, algo que pode apresentar diversas soluções, questões sem resposta, gera discussão, e que no universo computacional, representa a fuga a uma determinada regra que impede o alcance do objetivo.

 

Programação estruturada

 

A muitos anos, softwares eram desenvolvidos apenas quando se tinha um problema de grandes proporções a se resolver, com um volume de dados considerável e que exigia grande número de operações. Claro que hoje em dia existem softwares ou aplicativos (apps) que lidam com problemas triviais, de baixa complexidade e volume de dados praticamente negligente, mas que atendem a um número grande de usuários.

Mesmo com estas diferenças, os programas sempre sofreram com a necessidade de ter relevância para que saíssem do projeto para as “prateleiras” das lojas de informática. E temos que considerar outra dinâmica dos programas: sua complexidade aumenta de acordo com a complexidade do que pretende resolver, em outras palavras,

Seria ótimo poder apresentar pequenos programas e, ao final, dizer: “agora expanda isso para programas maiores”. Infelizmente não é assim. Um programa de mil linhas tem muito pouco a ver com um programa de 10 linhas. Programar não é uma atividade escalável, ou seja, estar preparado para escrever um programa de 10 linhas não vai prepará-lo para escrever um programa de 1000 linhas. (RIBEIRO 2018, p. 78)

Aplicar um programa de baixa complexidade a uma situação que exige mais etapas para sua resolução, significa, em termos práticos, ter que expandir seu código fonte, algo que é puramente textual. Este oneroso processo costumava causar problemas quando os programadores tentavam atalhos no processo de composição do código, de seu fluxo de execução. Tal situação seria o mesmo que um escritor orientar, em seu texto, que o leitor pulasse páginas,

Esse processo aconteceria por todo o livro, de acordo com outras condições externas. Várias leituras seriam possíveis, mas o difícil seria manter a coerência entre as várias possibilidades de leitura. Cada percurso de leitura deveria contar uma história coerente. Isso não é impossível de ser feito, mas envolveria um grande esforço mental do escritor para domar toda a complexidade da tarefa. Três ou quatro linhas de narrativa poderiam ser fáceis de organizar, mas, e se essas narrativas chegassem à casa das dezenas ou centenas em um único livro? Facilmente poderia haver alguma linha de narrativa sem sentido. (RIBEIRO 2018, p. 78)

Dentro da lógica e dos processos não se deve criar atalhos dentro dos programas de computador, pois com os diversos caminhos que o fluxo de execução pode seguir, existe uma necessidade de amarração a uma estrutura básica, de forma que permita manter a coerência do sistema mesmo em casos de ampliação do seu código para agregar novas funcionalidades.

Quando se adiciona códigos inadvertidamente, temos o chamado código espaguete, um emaranhado de código praticamente ilegível e pouco eficiente na resolução do problema que propõe. Para Ribeiro (2018, p. 78), é preciso pôr ordem nesse caos. (RIBEIRO 2018, p. 78)

Na programação estruturada, dividimos a solução do problema em blocos. Cada bloco executa uma ação que pode consistir em um teste, na repetição de comandos ou na obtenção de um resultado. Para manter a complexidade em um nível compreensível, cada bloco possui apenas uma entrada e uma saída para o fluxo da informação. Isso quer dizer que um bloco recebe alguma informação, processa-a e devolve algum resultado ao seu final. Note que falo em “blocos”. Cada bloco engloba uma ou várias ações efetivas para a solução do problema. Isso impede o surgimento do “código espaguete”. (RIBEIRO 2018, p. 78)

 

Quando se impõe uma estrutura, são estabelecidos blocos lógicos, cuja estrutura estabelece entradas e saídas únicas e com isso a sistemática de programação ganha melhor controle, mesmo em casos de programas complexos, o que, inclusive, facilita a depuração dos eventuais erros, como podemos observar na figura a seguir:

Figura 02:  Bloco de processamento.


Existe grande praticidade na construção de sistemas pela lógica dos blocos, que podem, inclusive, ser incorporados por blocos maiores, tal como as Matrioskas, aquelas bonecas russas que se encaixam umas nas outras. Mas o processo de incorporação de blocos mantém a dinâmica das entradas e saídas únicas e temos que onde um bloco começa, outro acaba de terminar seu processo.

Com a programação estruturada os blocos passam a apresentar regras de escopo bem definidas, e desta forma outras partes de um programa não podem inadvertidamente modificar variáveis ou redistribuir o fluxo de execução padrão. Podemos dizer que um dos destaques da programação estruturada é exatamente o de definir regras até mesmo para os desvios que podem ser realizados.

De acordo com Ribeiro (2018, p. 79), “O escopo de uma variável define em quais blocos a variável é visível, ou seja, o valor dessa variável só pode ser lido e às vezes modificado dentro daquele bloco.” O mesmo efeito ocorre com os desvios de execução, fazendo com que os desvios de um bloco voltem ao mesmo bloco antes que as demais instruções tenham início.

Dentro do contexto da programação estruturada podemos usar o termo paradigma de forma extremamente positiva, pois aqui, paradigma é programação estruturada, pois representa um modelo a ser seguido. Mas na programação também apresenta outros modelos, como o paradigma, a exemplo: a programação funcional, a programação orientada a eventos, orientada a aspecto e a orientada a objetos.

Com isso podemos perceber que cada linguagem de programação nasce para comportar melhor determinado paradigma, e de acordo com Aléssio (2017, p. 08) “Essa técnica permite uma posterior codificação em qualquer linguagem de programação de computadores, pois não se atinge um detalhamento de instruções ou comandos específicos, os quais caracterizam uma linguagem.” De acordo com esta linha de pensamento podemos conceituar como sendo o objetivo deste tipo de metodologia de projeto:

Agilizar a codificação da escrita de programas.

Facilitar a depuração da sua leitura.

Permitir a verificação de possíveis falhas apresentadas pelos programas.

 

O destaque, neste processo, é a facilidade de se conduzir as alterações e atualizações dos programas, mantendo seus objetivos e qualidade.

 

Cozinha x Computador

 

Longe da computação existe um processo vital ao ser humano que requer a mesma obrigatoriedade de sequência lógica que a criação de um software demanda: a Culinária! Já observou nos sites do tema que as receitas costumam ter instruções muito precisas, finitas, e em blocos? No que isso se assemelha senão na programação estruturada?

Portanto algoritmos são as receitas não culinárias que o computador vai seguir para produzir o prato das informações de saída que o usuário vai saborear ne desta forma,

Toda receita culinária é dividida em dois blocos de ação, sendo o bloco ingredientes, no qual se definem os dados a serem usados e as quantidades que devem estar preparadas e separadas para a elaboração da receita, e o bloco modo de preparo, em que estão descritos o programa de ações e a sequência de atividades. (MANZANO 2016, p. 27)

 

Embora a execução de um prato ou receita possa variar ligeiramente, tanto os blocos de ingredientes e de preparo trazem informações explícitas, um roteiro de sua realização e podem ocorrer problemas com o resultado final, e até mesmo inviabilizar a entrega do prato ou receita. De qualquer forma, ignorar algumas das informações dos blocos de ingredientes ou de procedimentos resulta em um produto final distinto ao proposto, e para Manzano (2016, p. 27)

Qualquer pessoa de posse de uma receita consegue, se seguir os seus passos, preparar a refeição indicada sem grandes dificuldades; essas pessoas são os cozinheiros. No entanto, existem outras que criam e inventam receitas, normalmente chamadas de mestres-cucas. Há ainda uma terceira pessoa, que simplesmente vai provar a refeição; é o usuário da receita preparada pela pessoa que cozinhou, que não é necessariamente um mestre-cuca, mas alguém que, ao longo de um determinado tempo, pode se tornar um.

Fica claro a grande semelhança que apresenta a produção de softwares com os processos de cozinha. Neste sentido temos o programador de computador no mesmo esquema que um chef, um “Mestre-cuca”, aquele encarregado de preparar o prato/sistema para a degustação/utilização do usuário. Assim como nos restaurantes, o usuário não apresenta grande curiosidade em saber como o prato foi feito, na programação o degustador não será ávido em conhecer o código fonte do seu sistema, desde que entregue o proposto.

Continuando a comparação cozinha e programação, não temos apenas os mestre-cucas, temos também os que montam com algoritmos pré-construídos, “São, na verdade, simples "cozinheiros", o que não é demérito nenhum, porém não têm experiência para resolver todos os problemas que possam surgir.” (MANZANO 2016, p. 27).

Em termos de nível de experiência, temos o programador/Mestre-cuca com grande bagagem em lógica de programação e muita experiência, de nível sênior e com isso capaz de criar seus algoritmos. Já em um nível imediatamente abaixo, temos o programador cozinheiro, com pouca sensibilidade na lógica de programação, pouca experiência e com isso denominado nível júnior.

Neste nível, o programador é capaz de desenvolver algoritmos simples, mas carece de supervisão de um programador sênior, e de acordo com Manzano (2016, p. 28):

O profissional pleno consegue desenvolver algoritmos de nível médio a complexo e necessita de supervisão e auxílio esporádicos de um programador sênior. Ao usar algoritmos prontos e escritos por outros programadores, gradativamente o programador júnior é preparado até se tornar pleno, e o programador pleno se prepara para chegar a um nível sênior e tornar-se, de certa forma, um "mestre-cuca".(MANZANO 2016, p. 28)

No menor escalão da programação temos o ajudante de cozinheiro, o programador ajudante que está em início de carreira, não assume criação de códigos complexos fazendo a montagem de programas com base em algoritmos prontos. Os algoritmos produzidos pelos ajudantes são simplificados e determinam a necessidade de supervisão de um programador sênior.

 

 

Atividade Extra

 

 

Que tal ligar o tema desta aula a algo que está no cotidiano de todo cidadão conectado: o youtube e seu algoritmo. São centenas de milhares de pessoas que tentam faturar com seus vídeos no youtube e existem os mais entusiasmados que buscam formas de aprimorar seus ganhos, e para tal partem para uma avaliação de como a plataforma monetiza seus youtubers destrinchando o código de seu algoritmo.

 

Desta forma recomendo a leitura do artigo que aborda como a plataforma de vídeos youtube calcula o valor para vídeos de música pelo link: https://core.ac.uk/download/pdf/268325698.pdf

 

 

Referência Bibliográfica

 

 

 

ALÉSSIO, Simone Cristina. Lógica e Técnicas de Programação: UNIASSELVI, 2017.

 

DAVY, Rodrigo. O que é a programação estruturada. 2019. Disponível em: <https://platzi.com.br/blog/programacao-estruturada/> Acesso em: 13/05/2021.

 

MANZANO, José Augusto N. G. Algoritmos: Logica para desenvolvimento de programação de computadores. - São Paulo: Érica, 2016.

 

MORAIS, Izabelly Soares de... et al. Algoritmo e programação. – Porto Alegre: SAGAH, 2018.

 

RIBEIRO, João Araujo. Introdução à programação e aos algoritmos. - Rio de Janeiro: LTC, 2019.

 

WAZLAWICK, Raul Sidnei. História da computação. – Rio de Janeiro: Elsevier, 2016.